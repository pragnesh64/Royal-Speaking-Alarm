// Auto-generated by build-vercel-api.ts — DO NOT EDIT

var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  alarms: () => alarms,
  insertAlarmSchema: () => insertAlarmSchema,
  insertMedicineSchema: () => insertMedicineSchema,
  insertMeetingSchema: () => insertMeetingSchema,
  insertPushSubscriptionSchema: () => insertPushSubscriptionSchema,
  insertUserSchema: () => insertUserSchema,
  medicines: () => medicines,
  meetings: () => meetings,
  otpCodes: () => otpCodes,
  pushSubscriptions: () => pushSubscriptions,
  sessions: () => sessions,
  users: () => users
});
import { pgTable, text, serial, integer, boolean, timestamp, varchar, index, jsonb } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { sql } from "drizzle-orm";
var sessions, users, otpCodes, alarms, medicines, meetings, pushSubscriptions, insertUserSchema, insertAlarmSchema, insertMedicineSchema, insertMeetingSchema, insertPushSubscriptionSchema;
var init_schema = __esm({
  "shared/schema.ts"() {
    "use strict";
    sessions = pgTable(
      "sessions",
      {
        sid: varchar("sid").primaryKey(),
        sess: jsonb("sess").notNull(),
        expire: timestamp("expire").notNull()
      },
      (table) => [index("IDX_session_expire").on(table.expire)]
    );
    users = pgTable("users", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      email: varchar("email").unique(),
      phone: varchar("phone"),
      passwordHash: varchar("password_hash"),
      authProvider: varchar("auth_provider").default("email"),
      // email, google, phone
      firstName: varchar("first_name"),
      lastName: varchar("last_name"),
      profileImageUrl: varchar("profile_image_url"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      // App-specific fields
      subscriptionStatus: text("subscription_status").default("trial"),
      trialEndsAt: timestamp("trial_ends_at").defaultNow(),
      language: text("language").default("english"),
      // Stripe fields for payment
      stripeCustomerId: varchar("stripe_customer_id"),
      stripeSubscriptionId: varchar("stripe_subscription_id")
    });
    otpCodes = pgTable("otp_codes", {
      id: serial("id").primaryKey(),
      phone: varchar("phone").notNull(),
      code: varchar("code").notNull(),
      expiresAt: timestamp("expires_at").notNull(),
      used: boolean("used").default(false),
      createdAt: timestamp("created_at").defaultNow()
    });
    alarms = pgTable("alarms", {
      id: serial("id").primaryKey(),
      userId: varchar("user_id").notNull(),
      title: text("title").notNull(),
      time: text("time").notNull(),
      // HH:mm format
      date: text("date"),
      // YYYY-MM-DD for specific date alarms
      days: text("days").array(),
      // ["Mon", "Tue", ...] for recurring
      isActive: boolean("is_active").default(true),
      type: text("type").default("speaking"),
      // speaking, custom_voice, text
      voiceUrl: text("voice_url"),
      // URL to recorded audio or uploaded image
      imageUrl: text("image_url"),
      // New field for alarm photo
      textToSpeak: text("text_to_speak"),
      voiceGender: text("voice_gender").default("female"),
      // male, female
      language: text("language").default("english"),
      // Added language support
      duration: integer("duration").default(30),
      // Duration in seconds to play
      loop: boolean("loop").default(true)
      // Whether to loop the audio/TTS
    });
    medicines = pgTable("medicines", {
      id: serial("id").primaryKey(),
      userId: varchar("user_id").notNull(),
      name: text("name").notNull(),
      photoUrl: text("photo_url"),
      timeOfDay: text("time_of_day"),
      times: text("times").array(),
      dosage: text("dosage"),
      isActive: boolean("is_active").default(true),
      type: text("type").default("speaking"),
      voiceUrl: text("voice_url"),
      textToSpeak: text("text_to_speak"),
      voiceGender: text("voice_gender").default("female"),
      language: text("language").default("english"),
      duration: integer("duration").default(30),
      loop: boolean("loop").default(true)
    });
    meetings = pgTable("meetings", {
      id: serial("id").primaryKey(),
      userId: varchar("user_id").notNull(),
      title: text("title").notNull(),
      date: text("date").notNull(),
      // YYYY-MM-DD
      time: text("time").notNull(),
      // HH:mm format
      location: text("location"),
      description: text("description"),
      participants: text("participants"),
      textToSpeak: text("text_to_speak"),
      enabled: boolean("enabled").default(true)
    });
    pushSubscriptions = pgTable("push_subscriptions", {
      id: serial("id").primaryKey(),
      userId: varchar("user_id").notNull(),
      endpoint: text("endpoint").notNull(),
      p256dh: text("p256dh").notNull(),
      auth: text("auth").notNull(),
      createdAt: timestamp("created_at").defaultNow()
    });
    insertUserSchema = createInsertSchema(users);
    insertAlarmSchema = createInsertSchema(alarms).omit({ id: true });
    insertMedicineSchema = createInsertSchema(medicines).omit({ id: true });
    insertMeetingSchema = createInsertSchema(meetings).omit({ id: true });
    insertPushSubscriptionSchema = createInsertSchema(pushSubscriptions).omit({ id: true });
  }
});

// server/db.ts
import { drizzle } from "drizzle-orm/node-postgres";
import pg from "pg";
var Pool, isNeon, pool, db;
var init_db = __esm({
  "server/db.ts"() {
    "use strict";
    init_schema();
    ({ Pool } = pg);
    if (!process.env.DATABASE_URL) {
      throw new Error(
        "DATABASE_URL must be set. Did you forget to provision a database?"
      );
    }
    isNeon = (process.env.DATABASE_URL || "").includes("neon.tech");
    pool = new Pool({
      connectionString: process.env.DATABASE_URL,
      // Pool sizing
      max: 10,
      // max connections in pool
      min: 2,
      // keep 2 warm connections ready
      // Timeouts
      idleTimeoutMillis: 3e4,
      // close idle connections after 30s
      connectionTimeoutMillis: 1e4,
      // fail fast if can't connect in 10s
      // Keep connections warm (critical for remote DBs like Neon)
      keepAlive: true,
      keepAliveInitialDelayMillis: 1e4,
      // SSL required for Neon and most cloud DBs
      ssl: isNeon ? { rejectUnauthorized: false } : void 0
    });
    pool.on("error", (err) => {
      console.error("[DB] Pool connection error (non-fatal):", err.message);
    });
    pool.query("SELECT 1").then(() => {
      console.log("[DB] Connection pool warmed up");
    }).catch((err) => {
      console.error("[DB] Pool warm-up failed:", err.message);
    });
    db = drizzle(pool, { schema: schema_exports });
  }
});

// server/replit_integrations/auth/storage.ts
import { eq as eq2 } from "drizzle-orm";
var AuthStorage, authStorage;
var init_storage = __esm({
  "server/replit_integrations/auth/storage.ts"() {
    "use strict";
    init_schema();
    init_db();
    AuthStorage = class {
      async getUser(id) {
        const [user] = await db.select().from(users).where(eq2(users.id, id));
        return user;
      }
      async getUserByEmail(email) {
        const [user] = await db.select().from(users).where(eq2(users.email, email));
        return user;
      }
      async upsertUser(userData) {
        const existingUser = await this.getUser(userData.id);
        if (existingUser) {
          const [user2] = await db.update(users).set({
            ...userData,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq2(users.id, userData.id)).returning();
          return user2;
        }
        if (userData.email) {
          const [existingByEmail] = await db.select().from(users).where(eq2(users.email, userData.email));
          if (existingByEmail) {
            const [user2] = await db.update(users).set({
              ...userData,
              updatedAt: /* @__PURE__ */ new Date()
            }).where(eq2(users.email, userData.email)).returning();
            return user2;
          }
        }
        const trialEndsAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3);
        const [user] = await db.insert(users).values({
          ...userData,
          subscriptionStatus: "trial",
          trialEndsAt
        }).returning();
        return user;
      }
    };
    authStorage = new AuthStorage();
  }
});

// server/replit_integrations/auth/localAuth.ts
var localAuth_exports = {};
__export(localAuth_exports, {
  setupLocalAuth: () => setupLocalAuth
});
import passport from "passport";
import { Strategy as LocalStrategy } from "passport-local";
import bcrypt from "bcryptjs";
import crypto from "crypto";
function setupLocalAuth(app2) {
  console.log("[Auth] Setting up Email/Password authentication");
  passport.use(
    new LocalStrategy(
      {
        usernameField: "email",
        passwordField: "password"
      },
      async (email, password, done) => {
        try {
          const user = await authStorage.getUserByEmail(email.toLowerCase());
          if (!user) {
            return done(null, false, { message: "Invalid email or password" });
          }
          if (!user.passwordHash) {
            return done(null, false, { message: "Invalid email or password" });
          }
          const isValid = await bcrypt.compare(password, user.passwordHash);
          if (!isValid) {
            return done(null, false, { message: "Invalid email or password" });
          }
          return done(null, { id: user.id });
        } catch (error) {
          return done(error);
        }
      }
    )
  );
  passport.serializeUser((user, cb) => cb(null, user.id));
  passport.deserializeUser(async (id, cb) => {
    try {
      const user = await authStorage.getUser(id);
      cb(null, user ? { id: user.id } : null);
    } catch (error) {
      cb(error);
    }
  });
  app2.post("/api/auth/register", async (req, res) => {
    try {
      const { email, password, firstName, lastName } = req.body;
      if (!email || !password) {
        return res.status(400).json({ message: "Email and password required" });
      }
      if (password.length < 6) {
        return res.status(400).json({ message: "Password must be at least 6 characters" });
      }
      const existingUser = await authStorage.getUserByEmail(email.toLowerCase());
      if (existingUser) {
        return res.status(400).json({ message: "Email already registered" });
      }
      const passwordHash = await bcrypt.hash(password, 10);
      const user = await authStorage.upsertUser({
        id: crypto.randomUUID(),
        email: email.toLowerCase(),
        passwordHash,
        firstName: firstName || "",
        lastName: lastName || "",
        profileImageUrl: ""
      });
      req.login({ id: user.id }, (err) => {
        if (err) {
          return res.status(500).json({ message: "Registration successful but login failed" });
        }
        const { passwordHash: _, ...safeUser } = user;
        res.status(201).json(safeUser);
      });
    } catch (error) {
      console.error("[Auth] Registration error:", error);
      res.status(500).json({ message: "Registration failed" });
    }
  });
  app2.post("/api/auth/login", (req, res, next) => {
    passport.authenticate("local", (err, user, info) => {
      if (err) {
        return res.status(500).json({ message: "Authentication failed" });
      }
      if (!user) {
        return res.status(401).json({ message: info?.message || "Invalid credentials" });
      }
      req.login(user, (loginErr) => {
        if (loginErr) {
          return res.status(500).json({ message: "Login failed" });
        }
        res.json({ message: "Login successful" });
      });
    })(req, res, next);
  });
  app2.post("/api/auth/logout", (req, res) => {
    req.logout((err) => {
      if (err) {
        return res.status(500).json({ message: "Logout failed" });
      }
      res.json({ message: "Logout successful" });
    });
  });
}
var init_localAuth = __esm({
  "server/replit_integrations/auth/localAuth.ts"() {
    "use strict";
    init_storage();
  }
});

// server/vercel-api.ts
import express from "express";
import cors from "cors";

// server/storage.ts
init_db();
init_schema();
import { eq, and, gt } from "drizzle-orm";
var DatabaseStorage = class {
  async getUser(id) {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }
  async getUserByUsername(username) {
    const [user] = await db.select().from(users).where(eq(users.email, username));
    return user;
  }
  async createUser(insertUser) {
    const [user] = await db.insert(users).values(insertUser).returning();
    return user;
  }
  async getAlarms(userId) {
    return await db.select().from(alarms).where(eq(alarms.userId, userId));
  }
  async createAlarm(alarm) {
    const [newAlarm] = await db.insert(alarms).values(alarm).returning();
    return newAlarm;
  }
  async updateAlarm(id, alarm) {
    const [updatedAlarm] = await db.update(alarms).set(alarm).where(eq(alarms.id, id)).returning();
    return updatedAlarm;
  }
  async deleteAlarm(id) {
    await db.delete(alarms).where(eq(alarms.id, id));
  }
  async getMedicines(userId) {
    return await db.select().from(medicines).where(eq(medicines.userId, userId));
  }
  async createMedicine(medicine) {
    const [newMedicine] = await db.insert(medicines).values(medicine).returning();
    return newMedicine;
  }
  async updateMedicine(id, medicine) {
    const [updatedMedicine] = await db.update(medicines).set(medicine).where(eq(medicines.id, id)).returning();
    return updatedMedicine;
  }
  async deleteMedicine(id) {
    await db.delete(medicines).where(eq(medicines.id, id));
  }
  async updateUser(id, update) {
    const [updatedUser] = await db.update(users).set(update).where(eq(users.id, id)).returning();
    if (!updatedUser) throw new Error("User not found");
    return updatedUser;
  }
  async getMeetings(userId) {
    return await db.select().from(meetings).where(eq(meetings.userId, userId));
  }
  async createMeeting(meeting) {
    const [newMeeting] = await db.insert(meetings).values(meeting).returning();
    return newMeeting;
  }
  async updateMeeting(id, meeting) {
    const [updatedMeeting] = await db.update(meetings).set(meeting).where(eq(meetings.id, id)).returning();
    return updatedMeeting;
  }
  async deleteMeeting(id) {
    await db.delete(meetings).where(eq(meetings.id, id));
  }
  // Auth methods
  async getUserByEmail(email) {
    const [user] = await db.select().from(users).where(eq(users.email, email));
    return user;
  }
  async getUserByPhone(phone) {
    const [user] = await db.select().from(users).where(eq(users.phone, phone));
    return user;
  }
  async createEmailUser(data) {
    const trialEndsAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3);
    const [user] = await db.insert(users).values({
      email: data.email,
      passwordHash: data.passwordHash,
      firstName: data.firstName,
      lastName: data.lastName,
      authProvider: data.authProvider,
      subscriptionStatus: "trial",
      trialEndsAt
    }).returning();
    return user;
  }
  async createPhoneUser(data) {
    const trialEndsAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3);
    const [user] = await db.insert(users).values({
      phone: data.phone,
      firstName: data.firstName,
      lastName: data.lastName,
      authProvider: data.authProvider,
      subscriptionStatus: "trial",
      trialEndsAt
    }).returning();
    return user;
  }
  async createOtp(data) {
    await db.insert(otpCodes).values({
      phone: data.phone,
      code: data.code,
      expiresAt: data.expiresAt
    });
  }
  async verifyOtp(phone, code) {
    const now = /* @__PURE__ */ new Date();
    const [otp] = await db.select().from(otpCodes).where(
      and(
        eq(otpCodes.phone, phone),
        eq(otpCodes.code, code),
        eq(otpCodes.used, false),
        gt(otpCodes.expiresAt, now)
      )
    );
    if (!otp) return false;
    await db.update(otpCodes).set({ used: true }).where(eq(otpCodes.id, otp.id));
    return true;
  }
};
var storage = new DatabaseStorage();

// shared/routes.ts
init_schema();
import { z } from "zod";
var errorSchemas = {
  validation: z.object({
    message: z.string(),
    field: z.string().optional()
  }),
  notFound: z.object({
    message: z.string()
  }),
  internal: z.object({
    message: z.string()
  })
};
var api = {
  alarms: {
    list: {
      method: "GET",
      path: "/api/alarms",
      responses: {
        200: z.array(z.custom())
      }
    },
    create: {
      method: "POST",
      path: "/api/alarms",
      input: insertAlarmSchema,
      responses: {
        201: z.custom(),
        400: errorSchemas.validation
      }
    },
    update: {
      method: "PUT",
      path: "/api/alarms/:id",
      input: insertAlarmSchema.partial(),
      responses: {
        200: z.custom(),
        404: errorSchemas.notFound
      }
    },
    delete: {
      method: "DELETE",
      path: "/api/alarms/:id",
      responses: {
        204: z.void(),
        404: errorSchemas.notFound
      }
    }
  },
  medicines: {
    list: {
      method: "GET",
      path: "/api/medicines",
      responses: {
        200: z.array(z.custom())
      }
    },
    create: {
      method: "POST",
      path: "/api/medicines",
      input: insertMedicineSchema,
      responses: {
        201: z.custom(),
        400: errorSchemas.validation
      }
    },
    update: {
      method: "PUT",
      path: "/api/medicines/:id",
      input: insertMedicineSchema.partial(),
      responses: {
        200: z.custom(),
        404: errorSchemas.notFound
      }
    },
    delete: {
      method: "DELETE",
      path: "/api/medicines/:id",
      responses: {
        204: z.void(),
        404: errorSchemas.notFound
      }
    }
  },
  meetings: {
    list: {
      method: "GET",
      path: "/api/meetings",
      responses: {
        200: z.array(z.custom())
      }
    },
    create: {
      method: "POST",
      path: "/api/meetings",
      input: insertMeetingSchema,
      responses: {
        201: z.custom(),
        400: errorSchemas.validation
      }
    },
    update: {
      method: "PATCH",
      path: "/api/meetings/:id",
      input: insertMeetingSchema.partial(),
      responses: {
        200: z.custom(),
        404: errorSchemas.notFound
      }
    },
    delete: {
      method: "DELETE",
      path: "/api/meetings/:id",
      responses: {
        204: z.void(),
        404: errorSchemas.notFound
      }
    }
  },
  upload: {
    create: {
      method: "POST",
      path: "/api/upload",
      input: z.any(),
      // FormData handled manually in route
      responses: {
        200: z.object({ url: z.string() }),
        400: errorSchemas.validation
      }
    }
  }
};

// server/routes.ts
import { z as z2 } from "zod";

// server/replit_integrations/auth/replitAuth.ts
init_storage();
init_db();
import * as client from "openid-client";
import { Strategy } from "openid-client/passport";
import passport2 from "passport";
import session from "express-session";
import memoize from "memoizee";
import connectPg from "connect-pg-simple";
import createMemoryStore from "memorystore";
var getOidcConfig = memoize(
  async () => {
    return await client.discovery(
      new URL(process.env.ISSUER_URL ?? "https://replit.com/oidc"),
      process.env.REPL_ID
    );
  },
  { maxAge: 3600 * 1e3 }
);
function getSession() {
  const sessionTtl = 7 * 24 * 60 * 60 * 1e3;
  const isProduction = process.env.NODE_ENV === "production";
  let store;
  if (isProduction && process.env.DATABASE_URL) {
    const pgStore = connectPg(session);
    store = new pgStore({
      pool,
      // Reuse the app's existing PG pool (has SSL configured)
      createTableIfMissing: true,
      ttl: sessionTtl / 1e3,
      // CRITICAL FIX: TTL in SECONDS, not milliseconds!
      tableName: "sessions",
      pruneSessionInterval: 60 * 15,
      // Prune expired sessions every 15 min
      errorLog: (err) => console.error("[Session Store] Error:", err)
    });
    console.log("[Session] Using PostgreSQL session store (shared pool)");
  } else {
    const MemoryStore = createMemoryStore(session);
    store = new MemoryStore({
      checkPeriod: 864e5
      // prune expired entries every 24h
    });
    console.log("[Session] Using in-memory session store (fast dev mode)");
  }
  return session({
    secret: process.env.SESSION_SECRET || "dev-secret-change-me",
    store,
    resave: false,
    // Don't save session if unmodified (reduces DB writes)
    saveUninitialized: false,
    // Don't create session until something stored (GDPR friendly)
    rolling: true,
    // CRITICAL FIX: Reset maxAge on every request (keeps session alive)
    proxy: true,
    // CRITICAL: Always trust proxy (required for Vercel HTTPS detection)
    name: "connect.sid",
    // Explicit session cookie name
    cookie: {
      httpOnly: false,
      // CRITICAL: false for WebView debugging (can check document.cookie)
      secure: true,
      // CRITICAL: true required for SameSite=None (API is HTTPS)
      sameSite: "none",
      // CRITICAL: 'none' required for cross-origin (app → API)
      maxAge: sessionTtl,
      path: "/",
      // Cookie available on all routes
      // CRITICAL: No domain restriction for cross-origin cookie support (mobile app)
      domain: void 0
    }
  });
}
function updateUserSession(user, tokens) {
  user.claims = tokens.claims();
  user.access_token = tokens.access_token;
  user.refresh_token = tokens.refresh_token;
  user.expires_at = user.claims?.exp;
}
async function upsertUser(claims) {
  await authStorage.upsertUser({
    id: claims["sub"],
    email: claims["email"],
    firstName: claims["first_name"],
    lastName: claims["last_name"],
    profileImageUrl: claims["profile_image_url"]
  });
}
async function setupAuth(app2) {
  app2.set("trust proxy", 1);
  app2.use(getSession());
  app2.use(passport2.initialize());
  app2.use(passport2.session());
  if (!process.env.REPL_ID) {
    console.log("[Auth] Running outside Replit - using Email/Password authentication");
    const { setupLocalAuth: setupLocalAuth2 } = await Promise.resolve().then(() => (init_localAuth(), localAuth_exports));
    setupLocalAuth2(app2);
    return;
  }
  const config = await getOidcConfig();
  const verify = async (tokens, verified) => {
    const claims = tokens.claims();
    const user = { id: claims["sub"] };
    updateUserSession(user, tokens);
    await upsertUser(claims);
    verified(null, user);
  };
  const registeredStrategies = /* @__PURE__ */ new Set();
  const ensureStrategy = (domain) => {
    const strategyName = `replitauth:${domain}`;
    if (!registeredStrategies.has(strategyName)) {
      const strategy = new Strategy(
        {
          name: strategyName,
          config,
          scope: "openid email profile offline_access",
          callbackURL: `https://${domain}/api/callback`
        },
        verify
      );
      passport2.use(strategy);
      registeredStrategies.add(strategyName);
    }
  };
  passport2.serializeUser((user, cb) => cb(null, user));
  passport2.deserializeUser((user, cb) => cb(null, user));
  app2.get("/api/login", (req, res, next) => {
    ensureStrategy(req.hostname);
    passport2.authenticate(`replitauth:${req.hostname}`, {
      prompt: "login consent",
      scope: ["openid", "email", "profile", "offline_access"]
    })(req, res, next);
  });
  app2.get("/api/callback", (req, res, next) => {
    ensureStrategy(req.hostname);
    passport2.authenticate(`replitauth:${req.hostname}`, {
      successReturnToOrRedirect: "/",
      failureRedirect: "/api/login"
    })(req, res, next);
  });
  app2.get("/api/logout", (req, res) => {
    req.logout(() => {
      res.redirect(
        client.buildEndSessionUrl(config, {
          client_id: process.env.REPL_ID,
          post_logout_redirect_uri: `${req.protocol}://${req.hostname}`
        }).href
      );
    });
  });
}

// server/replit_integrations/auth/index.ts
init_storage();

// server/replit_integrations/auth/routes.ts
init_storage();
function sanitizeUser(user) {
  if (!user) return void 0;
  const { passwordHash, ...safeUser } = user;
  return safeUser;
}
var userCache = /* @__PURE__ */ new Map();
var USER_CACHE_TTL = 60 * 1e3;
function getCachedUser(userId) {
  const entry = userCache.get(userId);
  if (entry && Date.now() < entry.expiry) {
    return entry.user;
  }
  userCache.delete(userId);
  return null;
}
function setCachedUser(userId, user) {
  userCache.set(userId, { user, expiry: Date.now() + USER_CACHE_TTL });
}
function invalidateUserCache(userId) {
  userCache.delete(userId);
}
function registerAuthRoutes(app2) {
  app2.get("/api/auth/user", async (req, res) => {
    try {
      if (!req.isAuthenticated() || !req.user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const userId = req.user.claims?.sub || req.user.id;
      if (!userId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const cached = getCachedUser(userId);
      if (cached) {
        return res.json(cached);
      }
      const user = await authStorage.getUser(userId);
      const sanitized = sanitizeUser(user);
      if (sanitized) {
        setCachedUser(userId, sanitized);
      }
      return res.json(sanitized);
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });
}

// server/seed.ts
async function seed() {
  const existingAlarms = await storage.getAlarms(1);
  if (existingAlarms.length > 0) return;
  console.log("Seeding database...");
  await storage.createAlarm({
    userId: 1,
    title: "Morning Wake Up",
    time: "07:00",
    days: ["Mon", "Tue", "Wed", "Thu", "Fri"],
    isActive: true,
    type: "speaking",
    textToSpeak: "Good morning! It's time to wake up and conquer the day.",
    voiceGender: "female"
  });
  await storage.createAlarm({
    userId: 1,
    title: "Water Reminder",
    time: "10:00",
    days: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
    isActive: true,
    type: "text",
    textToSpeak: "Drink some water to stay hydrated."
  });
  await storage.createMedicine({
    userId: 1,
    name: "Vitamin D",
    timeOfDay: "morning",
    dosage: "1 tablet",
    photoUrl: "https://placehold.co/100?text=Vit+D"
  });
  await storage.createMedicine({
    userId: 1,
    name: "Omega 3",
    timeOfDay: "afternoon",
    dosage: "1 capsule",
    photoUrl: "https://placehold.co/100?text=Omega3"
  });
  console.log("Seeding complete!");
}

// server/routes.ts
import bcrypt2 from "bcryptjs";

// server/stripeClient.ts
import Stripe from "stripe";
var connectionSettings;
async function getCredentials() {
  if (process.env.STRIPE_SECRET_KEY && process.env.STRIPE_PUBLISHABLE_KEY) {
    return {
      publishableKey: process.env.STRIPE_PUBLISHABLE_KEY,
      secretKey: process.env.STRIPE_SECRET_KEY
    };
  }
  const hostname = process.env.REPLIT_CONNECTORS_HOSTNAME;
  const xReplitToken = process.env.REPL_IDENTITY ? "repl " + process.env.REPL_IDENTITY : process.env.WEB_REPL_RENEWAL ? "depl " + process.env.WEB_REPL_RENEWAL : null;
  if (!xReplitToken) {
    throw new Error("Stripe credentials not found. Set STRIPE_SECRET_KEY and STRIPE_PUBLISHABLE_KEY environment variables.");
  }
  const connectorName = "stripe";
  const isProduction = process.env.REPLIT_DEPLOYMENT === "1";
  const targetEnvironment = isProduction ? "production" : "development";
  const url = new URL(`https://${hostname}/api/v2/connection`);
  url.searchParams.set("include_secrets", "true");
  url.searchParams.set("connector_names", connectorName);
  url.searchParams.set("environment", targetEnvironment);
  const response = await fetch(url.toString(), {
    headers: {
      "Accept": "application/json",
      "X_REPLIT_TOKEN": xReplitToken
    }
  });
  const data = await response.json();
  connectionSettings = data.items?.[0];
  if (!connectionSettings || (!connectionSettings.settings.publishable || !connectionSettings.settings.secret)) {
    throw new Error(`Stripe ${targetEnvironment} connection not found`);
  }
  return {
    publishableKey: connectionSettings.settings.publishable,
    secretKey: connectionSettings.settings.secret
  };
}
async function getUncachableStripeClient() {
  const { secretKey } = await getCredentials();
  return new Stripe(secretKey, {
    apiVersion: "2025-08-27.basil"
  });
}
async function getStripePublishableKey() {
  const { publishableKey } = await getCredentials();
  return publishableKey;
}

// server/routes.ts
init_db();
import { sql as sql2 } from "drizzle-orm";
import Razorpay from "razorpay";
import crypto2 from "crypto";

// server/pushNotification.ts
init_db();
init_schema();
import webPush from "web-push";
import { eq as eq3 } from "drizzle-orm";
var vapidKeys = {
  publicKey: process.env.VAPID_PUBLIC_KEY || "",
  privateKey: process.env.VAPID_PRIVATE_KEY || ""
};
if (!vapidKeys.publicKey || !vapidKeys.privateKey) {
  const generatedKeys = webPush.generateVAPIDKeys();
  vapidKeys = generatedKeys;
  console.log("[Push] Generated VAPID keys. Add these to environment:");
  console.log("VAPID_PUBLIC_KEY=" + generatedKeys.publicKey);
  console.log("VAPID_PRIVATE_KEY=" + generatedKeys.privateKey);
}
webPush.setVapidDetails(
  "mailto:support@mypa.app",
  vapidKeys.publicKey,
  vapidKeys.privateKey
);
function getVapidPublicKey() {
  return vapidKeys.publicKey;
}
async function sendPushNotification(userId, payload) {
  const subscriptions = await db.select().from(pushSubscriptions).where(eq3(pushSubscriptions.userId, userId));
  let success = 0;
  let failed = 0;
  for (const sub of subscriptions) {
    try {
      await webPush.sendNotification(
        {
          endpoint: sub.endpoint,
          keys: {
            p256dh: sub.p256dh,
            auth: sub.auth
          }
        },
        JSON.stringify(payload),
        {
          TTL: 60,
          urgency: "high",
          headers: {
            "Urgency": "high"
          }
        }
      );
      success++;
      console.log(`[Push] Notification sent to user ${userId}`);
    } catch (error) {
      failed++;
      console.error(`[Push] Failed to send notification:`, error.message);
      if (error.statusCode === 410 || error.statusCode === 404) {
        await db.delete(pushSubscriptions).where(eq3(pushSubscriptions.id, sub.id));
        console.log(`[Push] Removed invalid subscription ${sub.id}`);
      }
    }
  }
  return { success, failed };
}
async function savePushSubscription(userId, endpoint, p256dh, auth) {
  const existing = await db.select().from(pushSubscriptions).where(eq3(pushSubscriptions.endpoint, endpoint));
  if (existing.length > 0) {
    await db.update(pushSubscriptions).set({ userId, p256dh, auth }).where(eq3(pushSubscriptions.endpoint, endpoint));
  } else {
    await db.insert(pushSubscriptions).values({
      userId,
      endpoint,
      p256dh,
      auth
    });
  }
  console.log(`[Push] Subscription saved for user ${userId}`);
}
async function removePushSubscription(endpoint) {
  await db.delete(pushSubscriptions).where(eq3(pushSubscriptions.endpoint, endpoint));
  console.log(`[Push] Subscription removed`);
}

// server/alarmScheduler.ts
init_db();
init_schema();
import { eq as eq4 } from "drizzle-orm";
var schedulerInterval = null;
var lastCheckedMinute = "";
function getCurrentTimeIST() {
  const now = /* @__PURE__ */ new Date();
  const options = {
    timeZone: "Asia/Kolkata",
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
    weekday: "short",
    year: "numeric",
    month: "2-digit",
    day: "2-digit"
  };
  const formatter = new Intl.DateTimeFormat("en-IN", options);
  const parts = formatter.formatToParts(now);
  const getValue = (type) => parts.find((p) => p.type === type)?.value || "";
  const hours = getValue("hour").padStart(2, "0");
  const minutes = getValue("minute").padStart(2, "0");
  const time = `${hours}:${minutes}`;
  const weekdayMap = {
    "Sun": "Sun",
    "Mon": "Mon",
    "Tue": "Tue",
    "Wed": "Wed",
    "Thu": "Thu",
    "Fri": "Fri",
    "Sat": "Sat"
  };
  const day = weekdayMap[getValue("weekday")] || getValue("weekday");
  const year = getValue("year");
  const month = getValue("month").padStart(2, "0");
  const dateNum = getValue("day").padStart(2, "0");
  const date = `${year}-${month}-${dateNum}`;
  return { time, day, date, minutes: parseInt(minutes) };
}
function timeMatches(alarmTime, currentTime) {
  const alarmHHMM = alarmTime.substring(0, 5);
  return alarmHHMM === currentTime;
}
async function checkAndSendAlarms() {
  const { time, day, date } = getCurrentTimeIST();
  const minuteKey = `${date}-${time}`;
  if (minuteKey === lastCheckedMinute) {
    return;
  }
  lastCheckedMinute = minuteKey;
  console.log(`[Scheduler] Checking at ${time} on ${day} (${date})`);
  try {
    const [activeAlarms, activeMedicines, activeMeetings] = await Promise.all([
      db.select().from(alarms).where(eq4(alarms.isActive, true)),
      db.select().from(medicines).where(eq4(medicines.isActive, true)),
      db.select().from(meetings).where(eq4(meetings.enabled, true))
    ]);
    const pushPromises = [];
    for (const alarm of activeAlarms) {
      let shouldTrigger = false;
      if (timeMatches(alarm.time, time)) {
        if (alarm.date) {
          shouldTrigger = alarm.date === date;
        } else if (alarm.days && alarm.days.length > 0) {
          shouldTrigger = alarm.days.includes(day);
        } else {
          shouldTrigger = true;
        }
      }
      if (shouldTrigger) {
        console.log(`[Scheduler] Triggering alarm ${alarm.id}: ${alarm.title}`);
        pushPromises.push(
          sendPushNotification(alarm.userId, {
            title: alarm.title || "MyPA Alarm",
            body: alarm.textToSpeak || `${alarm.title} - Time to wake up!`,
            type: "alarm",
            id: alarm.id,
            textToSpeak: alarm.textToSpeak || void 0,
            alarmType: alarm.type || "speaking",
            voiceUrl: alarm.voiceUrl || void 0,
            imageUrl: alarm.imageUrl || void 0,
            language: alarm.language || "english",
            days: alarm.days || void 0,
            duration: alarm.duration || 30,
            loop: alarm.loop !== false,
            voiceGender: alarm.voiceGender || "female"
          })
        );
      }
    }
    for (const medicine of activeMedicines) {
      if (medicine.times && medicine.times.length > 0) {
        for (const medTime of medicine.times) {
          if (timeMatches(medTime, time)) {
            console.log(`[Scheduler] Triggering medicine ${medicine.id}: ${medicine.name}`);
            pushPromises.push(
              sendPushNotification(medicine.userId, {
                title: `Medicine: ${medicine.name}`,
                body: medicine.textToSpeak || `Time to take ${medicine.name}${medicine.dosage ? ` - ${medicine.dosage}` : ""}`,
                type: "medicine",
                id: medicine.id,
                textToSpeak: medicine.textToSpeak || void 0,
                alarmType: medicine.type || "speaking",
                voiceUrl: medicine.voiceUrl || void 0,
                imageUrl: medicine.photoUrl || void 0,
                photoUrl: medicine.photoUrl || void 0,
                dosage: medicine.dosage || void 0,
                language: medicine.language || "english",
                duration: medicine.duration || 30,
                loop: medicine.loop !== false,
                voiceGender: medicine.voiceGender || "female"
              })
            );
          }
        }
      }
    }
    for (const meeting of activeMeetings) {
      if (timeMatches(meeting.time, time) && meeting.date === date) {
        console.log(`[Scheduler] Triggering meeting ${meeting.id}: ${meeting.title}`);
        pushPromises.push(
          sendPushNotification(meeting.userId, {
            title: `Meeting: ${meeting.title}`,
            body: meeting.textToSpeak || `${meeting.title}${meeting.location ? ` at ${meeting.location}` : ""}`,
            type: "meeting",
            id: meeting.id,
            textToSpeak: meeting.textToSpeak || void 0
          })
        );
      }
    }
    if (pushPromises.length > 0) {
      await Promise.allSettled(pushPromises);
    }
  } catch (error) {
    console.error("[Scheduler] Error checking alarms:", error);
  }
}
function startAlarmScheduler() {
  if (schedulerInterval) {
    console.log("[Scheduler] Already running");
    return;
  }
  console.log("[Scheduler] Starting alarm scheduler...");
  schedulerInterval = setInterval(checkAndSendAlarms, 30 * 1e3);
  checkAndSendAlarms();
}

// server/alarmToggleLogic.ts
function hasFutureOccurrence(alarm) {
  const now = /* @__PURE__ */ new Date();
  const currentTime = now.toLocaleString("en-IN", {
    timeZone: "Asia/Kolkata",
    hour: "2-digit",
    minute: "2-digit",
    hour12: false
  }).replace(/\s/g, "");
  const currentDate = now.toLocaleDateString("en-CA", { timeZone: "Asia/Kolkata" });
  const currentDay = now.toLocaleDateString("en-US", {
    timeZone: "Asia/Kolkata",
    weekday: "short"
  });
  if (alarm.date) {
    if (alarm.date > currentDate) {
      return true;
    }
    if (alarm.date === currentDate) {
      return alarm.time > currentTime;
    }
    return false;
  }
  if (alarm.days && alarm.days.length > 0) {
    const dayOrder = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    const currentDayIndex = dayOrder.indexOf(currentDay);
    const hasTodayInDays = alarm.days.includes(currentDay);
    if (hasTodayInDays && alarm.time > currentTime) {
      return true;
    }
    return true;
  }
  return alarm.time > currentTime;
}
function setAlarmActiveStatus(alarmData) {
  const shouldBeActive = hasFutureOccurrence({
    time: alarmData.time,
    date: alarmData.date,
    days: alarmData.days
  });
  return {
    ...alarmData,
    isActive: alarmData.isActive === false ? false : shouldBeActive
  };
}

// server/routes.ts
import multer from "multer";
async function registerRoutes(httpServer2, app2) {
  await setupAuth(app2);
  registerAuthRoutes(app2);
  seed().catch(console.error);
  app2.get(api.alarms.list.path, async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const alarms3 = await storage.getAlarms(req.user.id);
    res.json(alarms3);
  });
  app2.post(api.alarms.create.path, async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    try {
      let input = {
        ...req.body,
        userId: req.user.id
      };
      input = setAlarmActiveStatus(input);
      const alarm = await storage.createAlarm(input);
      res.status(201).json(alarm);
    } catch (err) {
      if (err instanceof z2.ZodError) {
        res.status(400).json({ message: err.errors[0].message });
        return;
      }
      throw err;
    }
  });
  app2.put(api.alarms.update.path, async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    try {
      let input = {
        ...req.body,
        userId: req.user.id
      };
      const requestKeys = Object.keys(req.body);
      const isManualToggle = requestKeys.length === 1 && requestKeys[0] === "isActive";
      if (!isManualToggle) {
        input = setAlarmActiveStatus(input);
      }
      const alarm = await storage.updateAlarm(Number(req.params.id), input);
      res.json(alarm);
    } catch (err) {
      if (err instanceof z2.ZodError) {
        res.status(400).json({ message: err.errors[0].message });
        return;
      }
      res.status(404).json({ message: "Alarm not found" });
    }
  });
  app2.delete(api.alarms.delete.path, async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    await storage.deleteAlarm(Number(req.params.id));
    res.status(204).end();
  });
  app2.get(api.medicines.list.path, async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const medicines3 = await storage.getMedicines(req.user.id);
    res.json(medicines3);
  });
  app2.post(api.medicines.create.path, async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    try {
      const input = {
        ...req.body,
        userId: req.user.id
      };
      const medicine = await storage.createMedicine(input);
      res.status(201).json(medicine);
    } catch (err) {
      if (err instanceof z2.ZodError) {
        res.status(400).json({ message: err.errors[0].message });
        return;
      }
      throw err;
    }
  });
  app2.put(api.medicines.update.path, async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    try {
      const input = {
        ...req.body,
        userId: req.user.id
      };
      const medicine = await storage.updateMedicine(Number(req.params.id), input);
      res.json(medicine);
    } catch (err) {
      if (err instanceof z2.ZodError) {
        res.status(400).json({ message: err.errors[0].message });
        return;
      }
      res.status(404).json({ message: "Medicine not found" });
    }
  });
  app2.delete(api.medicines.delete.path, async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    await storage.deleteMedicine(Number(req.params.id));
    res.status(204).end();
  });
  app2.get(api.meetings.list.path, async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const meetings3 = await storage.getMeetings(req.user.id);
    res.json(meetings3);
  });
  app2.post(api.meetings.create.path, async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    try {
      const input = {
        ...req.body,
        userId: req.user.id
      };
      const meeting = await storage.createMeeting(input);
      res.status(201).json(meeting);
    } catch (err) {
      if (err instanceof z2.ZodError) {
        res.status(400).json({ message: err.errors[0].message });
        return;
      }
      throw err;
    }
  });
  app2.patch(api.meetings.update.path, async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    try {
      const input = {
        ...req.body,
        userId: req.user.id
      };
      const meeting = await storage.updateMeeting(Number(req.params.id), input);
      res.json(meeting);
    } catch (err) {
      res.status(404).json({ message: "Meeting not found" });
    }
  });
  app2.delete(api.meetings.delete.path, async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    await storage.deleteMeeting(Number(req.params.id));
    res.status(204).end();
  });
  app2.patch("/api/user/settings", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const userId = req.user.id;
    const user = await storage.updateUser(userId, req.body);
    invalidateUserCache(userId);
    res.json(user);
  });
  const uploadStorage = multer.memoryStorage();
  const uploadMiddleware = multer({ storage: uploadStorage, limits: { fileSize: 10 * 1024 * 1024 } });
  app2.post(api.upload.create.path, uploadMiddleware.single("file"), async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    if (!req.file) {
      return res.status(400).json({ error: "No file uploaded" });
    }
    const base64 = `data:${req.file.mimetype};base64,${req.file.buffer.toString("base64")}`;
    res.json({ url: base64 });
  });
  const sanitizeUser2 = (user) => {
    const { passwordHash, ...safeUser } = user;
    return safeUser;
  };
  const signupSchema = z2.object({
    email: z2.string().email("Invalid email format"),
    password: z2.string().min(6, "Password must be at least 6 characters"),
    name: z2.string().optional()
  });
  const loginSchema = z2.object({
    email: z2.string().email("Invalid email format"),
    password: z2.string().min(1, "Password is required")
  });
  const phoneSchema = z2.object({
    phone: z2.string().min(10, "Invalid phone number")
  });
  const verifyOtpSchema = z2.object({
    phone: z2.string().min(10, "Invalid phone number"),
    otp: z2.string().length(6, "OTP must be 6 digits"),
    name: z2.string().optional()
  });
  app2.post("/api/auth/signup", async (req, res) => {
    try {
      const validatedData = signupSchema.parse(req.body);
      const { email, password, name } = validatedData;
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(400).json({ message: "Email already registered" });
      }
      const passwordHash = await bcrypt2.hash(password, 12);
      const nameParts = (name || "").split(" ");
      const user = await storage.createEmailUser({
        email,
        passwordHash,
        firstName: nameParts[0] || email.split("@")[0],
        lastName: nameParts.slice(1).join(" ") || "",
        authProvider: "email"
      });
      req.login(user, (err) => {
        if (err) {
          return res.status(500).json({ message: "Login failed after signup" });
        }
        res.json({ success: true, user: sanitizeUser2(user) });
      });
    } catch (err) {
      if (err instanceof z2.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      console.error("Signup error:", err);
      res.status(500).json({ message: "Signup failed" });
    }
  });
  app2.post("/api/auth/login", async (req, res) => {
    try {
      const validatedData = loginSchema.parse(req.body);
      const { email, password } = validatedData;
      const user = await storage.getUserByEmail(email);
      if (!user || !user.passwordHash) {
        return res.status(401).json({ message: "Invalid email or password" });
      }
      const validPassword = await bcrypt2.compare(password, user.passwordHash);
      if (!validPassword) {
        return res.status(401).json({ message: "Invalid email or password" });
      }
      req.login(user, (err) => {
        if (err) {
          return res.status(500).json({ message: "Login failed" });
        }
        res.json({ success: true, user: sanitizeUser2(user) });
      });
    } catch (err) {
      if (err instanceof z2.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      console.error("Login error:", err);
      res.status(500).json({ message: "Login failed" });
    }
  });
  app2.post("/api/auth/send-otp", async (req, res) => {
    try {
      const validatedData = phoneSchema.parse(req.body);
      let { phone } = validatedData;
      phone = phone.replace(/^\+91/, "").replace(/^91/, "").replace(/\s/g, "");
      if (phone.length !== 10) {
        return res.status(400).json({ message: "Please enter valid 10-digit mobile number" });
      }
      const otp = Math.floor(1e5 + Math.random() * 9e5).toString();
      const expiresAt = new Date(Date.now() + 10 * 60 * 1e3);
      await storage.createOtp({ phone, code: otp, expiresAt });
      const fast2smsKey = process.env.FAST2SMS_API_KEY;
      if (fast2smsKey) {
        try {
          const message = `Your MyPA verification code is: ${otp}. Valid for 10 minutes.`;
          const apiUrl = `https://www.fast2sms.com/dev/bulkV2?authorization=${fast2smsKey}&message=${encodeURIComponent(message)}&route=q&numbers=${phone}`;
          console.log(`[Fast2SMS] Sending to ${phone}...`);
          const response = await fetch(apiUrl);
          const result = await response.json();
          console.log(`[Fast2SMS] Response:`, JSON.stringify(result, null, 2));
          if (!result.return) {
            console.error("[Fast2SMS] Error - SMS not sent:", result.message || result);
            console.log(`[FALLBACK] OTP for ${phone}: ${otp}`);
          } else {
            console.log(`[Fast2SMS] SUCCESS - OTP sent to ${phone}`);
          }
        } catch (smsError) {
          console.error("[Fast2SMS] Exception:", smsError);
          console.log(`[FALLBACK] OTP for ${phone}: ${otp}`);
        }
      } else {
        console.log(`[DEV] OTP for ${phone}: ${otp} (Fast2SMS not configured)`);
      }
      res.json({ success: true, message: "OTP sent successfully" });
    } catch (err) {
      if (err instanceof z2.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      console.error("Send OTP error:", err);
      res.status(500).json({ message: "Failed to send OTP" });
    }
  });
  app2.post("/api/auth/verify-otp", async (req, res) => {
    try {
      const validatedData = verifyOtpSchema.parse(req.body);
      const { phone, otp, name } = validatedData;
      const validOtp = await storage.verifyOtp(phone, otp);
      if (!validOtp) {
        return res.status(401).json({ message: "Invalid or expired OTP" });
      }
      let user = await storage.getUserByPhone(phone);
      if (!user) {
        const nameParts = (name || "").split(" ");
        user = await storage.createPhoneUser({
          phone,
          firstName: nameParts[0] || phone.slice(-4),
          lastName: nameParts.slice(1).join(" ") || "",
          authProvider: "phone"
        });
      }
      req.login(user, (err) => {
        if (err) {
          return res.status(500).json({ message: "Login failed" });
        }
        res.json({ success: true, user: sanitizeUser2(user) });
      });
    } catch (err) {
      if (err instanceof z2.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      console.error("Verify OTP error:", err);
      res.status(500).json({ message: "Verification failed" });
    }
  });
  app2.get("/api/stripe/publishable-key", async (req, res) => {
    try {
      const key = await getStripePublishableKey();
      res.json({ publishableKey: key });
    } catch (error) {
      console.error("Error getting publishable key:", error);
      res.status(500).json({ message: "Stripe not configured" });
    }
  });
  app2.get("/api/stripe/products", async (req, res) => {
    try {
      const result = await db.execute(sql2`
        SELECT 
          p.id as product_id,
          p.name as product_name,
          p.description,
          pr.id as price_id,
          pr.unit_amount,
          pr.currency,
          pr.recurring
        FROM stripe.products p
        LEFT JOIN stripe.prices pr ON pr.product = p.id AND pr.active = true
        WHERE p.active = true
        ORDER BY pr.unit_amount ASC
      `);
      res.json({ products: result.rows });
    } catch (error) {
      console.error("Error fetching products:", error);
      res.status(500).json({ message: "Failed to fetch products" });
    }
  });
  app2.post("/api/stripe/checkout", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    try {
      const { priceId } = req.body;
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const stripe = await getUncachableStripeClient();
      let customerId = user.stripeCustomerId;
      if (!customerId) {
        const customer = await stripe.customers.create({
          email: user.email || void 0,
          metadata: { userId: user.id }
        });
        customerId = customer.id;
        await db.execute(sql2`
          UPDATE users SET stripe_customer_id = ${customerId} WHERE id = ${userId}
        `);
      }
      const session2 = await stripe.checkout.sessions.create({
        customer: customerId,
        payment_method_types: ["card"],
        line_items: [{ price: priceId, quantity: 1 }],
        mode: "subscription",
        success_url: `${req.protocol}://${req.get("host")}/settings?payment=success`,
        cancel_url: `${req.protocol}://${req.get("host")}/settings?payment=cancelled`,
        subscription_data: {
          trial_period_days: 30
        }
      });
      res.json({ url: session2.url });
    } catch (error) {
      console.error("Checkout error:", error);
      res.status(500).json({ message: error.message || "Checkout failed" });
    }
  });
  app2.get("/api/stripe/subscription", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.stripeSubscriptionId) {
        return res.json({ subscription: null, status: user?.subscriptionStatus || "trial" });
      }
      const result = await db.execute(sql2`
        SELECT * FROM stripe.subscriptions WHERE id = ${user.stripeSubscriptionId}
      `);
      res.json({
        subscription: result.rows[0] || null,
        status: user.subscriptionStatus
      });
    } catch (error) {
      console.error("Error fetching subscription:", error);
      res.status(500).json({ message: "Failed to fetch subscription" });
    }
  });
  app2.post("/api/stripe/portal", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.stripeCustomerId) {
        return res.status(400).json({ message: "No billing account found" });
      }
      const stripe = await getUncachableStripeClient();
      const session2 = await stripe.billingPortal.sessions.create({
        customer: user.stripeCustomerId,
        return_url: `${req.protocol}://${req.get("host")}/settings`
      });
      res.json({ url: session2.url });
    } catch (error) {
      console.error("Portal error:", error);
      res.status(500).json({ message: error.message || "Portal access failed" });
    }
  });
  let razorpay = null;
  if (process.env.RAZORPAY_KEY_ID && process.env.RAZORPAY_KEY_SECRET) {
    razorpay = new Razorpay({
      key_id: process.env.RAZORPAY_KEY_ID,
      key_secret: process.env.RAZORPAY_KEY_SECRET
    });
    console.log("[Razorpay] Initialized");
  } else {
    console.log("[Razorpay] Credentials not found - Razorpay disabled");
  }
  app2.get("/api/razorpay/key", (req, res) => {
    res.json({ key: process.env.RAZORPAY_KEY_ID });
  });
  app2.post("/api/razorpay/webhook", async (req, res) => {
    if (!razorpay) {
      return res.status(503).json({ message: "Razorpay not configured" });
    }
    try {
      const webhookSignature = req.headers["x-razorpay-signature"];
      const webhookSecret = process.env.RAZORPAY_WEBHOOK_SECRET;
      if (webhookSecret && webhookSignature) {
        const body = JSON.stringify(req.body);
        const expectedSignature = crypto2.createHmac("sha256", webhookSecret).update(body).digest("hex");
        if (expectedSignature !== webhookSignature) {
          console.log("Razorpay webhook signature mismatch");
          return res.status(400).json({ message: "Invalid signature" });
        }
      }
      const event = req.body.event;
      const payload = req.body.payload;
      if (event === "payment.captured") {
        const payment = payload.payment.entity;
        const orderId = payment.order_id;
        const order = await razorpay.orders.fetch(orderId);
        const userId = order.notes?.userId;
        if (userId) {
          const plan = order.amount === 600 ? "yearly" : "monthly";
          const subscriptionEnd = /* @__PURE__ */ new Date();
          if (plan === "yearly") {
            subscriptionEnd.setFullYear(subscriptionEnd.getFullYear() + 1);
          } else {
            subscriptionEnd.setDate(subscriptionEnd.getDate() + 30);
          }
          await db.execute(sql2`
            UPDATE users 
            SET subscription_status = 'active',
                trial_ends_at = ${subscriptionEnd.toISOString()},
                updated_at = NOW()
            WHERE id = ${userId}
          `);
          console.log(`Webhook: Subscription activated for user ${userId}, plan: ${plan}`);
        }
      }
      res.json({ status: "ok" });
    } catch (error) {
      console.error("Razorpay webhook error:", error);
      res.status(500).json({ message: error.message });
    }
  });
  app2.post("/api/razorpay/create-order", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    if (!razorpay) {
      return res.status(503).json({ message: "Razorpay not configured" });
    }
    try {
      const { plan } = req.body;
      if (plan !== "monthly" && plan !== "yearly") {
        return res.status(400).json({ message: "Invalid plan. Use 'monthly' or 'yearly'" });
      }
      const amount = plan === "yearly" ? 600 : 500;
      const order = await razorpay.orders.create({
        amount,
        currency: "INR",
        receipt: `mypa_${Date.now()}`,
        notes: {
          userId: req.user.id,
          plan
        }
      });
      res.json({
        orderId: order.id,
        amount: order.amount,
        currency: order.currency,
        plan
      });
    } catch (error) {
      console.error("Razorpay order error:", error);
      res.status(500).json({ message: error.message || "Failed to create order" });
    }
  });
  app2.post("/api/razorpay/verify-payment", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    if (!razorpay) {
      return res.status(503).json({ message: "Razorpay not configured" });
    }
    try {
      const { razorpay_order_id, razorpay_payment_id, razorpay_signature } = req.body;
      const userId = req.user.id;
      const body = razorpay_order_id + "|" + razorpay_payment_id;
      const expectedSignature = crypto2.createHmac("sha256", process.env.RAZORPAY_KEY_SECRET).update(body.toString()).digest("hex");
      if (expectedSignature !== razorpay_signature) {
        return res.status(400).json({ message: "Invalid payment signature" });
      }
      const order = await razorpay.orders.fetch(razorpay_order_id);
      const payment = await razorpay.payments.fetch(razorpay_payment_id);
      if (payment.status !== "captured") {
        return res.status(400).json({ message: "Payment not captured" });
      }
      if (order.notes?.userId !== userId) {
        return res.status(400).json({ message: "Order user mismatch" });
      }
      const plan = order.amount === 600 ? "yearly" : "monthly";
      const subscriptionEnd = /* @__PURE__ */ new Date();
      if (plan === "yearly") {
        subscriptionEnd.setFullYear(subscriptionEnd.getFullYear() + 1);
      } else {
        subscriptionEnd.setDate(subscriptionEnd.getDate() + 30);
      }
      await db.execute(sql2`
        UPDATE users 
        SET subscription_status = 'active',
            trial_ends_at = ${subscriptionEnd.toISOString()},
            updated_at = NOW()
        WHERE id = ${userId}
      `);
      res.json({
        success: true,
        message: "Payment verified successfully",
        subscriptionEnd: subscriptionEnd.toISOString()
      });
    } catch (error) {
      console.error("Payment verification error:", error);
      res.status(500).json({ message: error.message || "Payment verification failed" });
    }
  });
  app2.get("/api/push/vapid-key", (req, res) => {
    res.json({ publicKey: getVapidPublicKey() });
  });
  app2.post("/api/push/subscribe", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    try {
      const { endpoint, keys } = req.body;
      if (!endpoint || !keys?.p256dh || !keys?.auth) {
        return res.status(400).json({ message: "Invalid subscription data" });
      }
      await savePushSubscription(
        req.user.id,
        endpoint,
        keys.p256dh,
        keys.auth
      );
      res.json({ success: true, message: "Push subscription saved" });
    } catch (error) {
      console.error("Push subscribe error:", error);
      res.status(500).json({ message: error.message || "Failed to save subscription" });
    }
  });
  app2.post("/api/push/unsubscribe", async (req, res) => {
    try {
      const { endpoint } = req.body;
      if (endpoint) {
        await removePushSubscription(endpoint);
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Push unsubscribe error:", error);
      res.status(500).json({ message: error.message });
    }
  });
  app2.post("/api/push/test", async (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    try {
      const result = await sendPushNotification(req.user.id, {
        title: "MyPA Test",
        body: "Push notification working!",
        type: "alarm"
      });
      res.json({ sent: result.success, failed: result.failed });
    } catch (error) {
      console.error("Push test error:", error);
      res.status(500).json({ message: error.message });
    }
  });
  app2.post("/api/push/snooze", async (req, res) => {
    try {
      const { alarmId, minutes } = req.body;
      console.log(`[Snooze] Alarm ${alarmId} snoozed for ${minutes} minutes`);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  });
  startAlarmScheduler();
  return httpServer2;
}

// server/vercel-api.ts
import { createServer } from "http";
var app = express();
app.use(cors({
  origin: function(origin, callback) {
    callback(null, true);
  },
  credentials: true,
  // CRITICAL: Allow cookies for session
  methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization", "X-Requested-With", "Cookie", "Set-Cookie"],
  exposedHeaders: ["Set-Cookie"],
  maxAge: 86400
  // Cache preflight for 24 hours
}));
console.log("[CORS] Enabled for Vercel serverless");
app.set("etag", "weak");
app.set("trust proxy", 1);
app.use(
  express.json({
    limit: "10mb",
    verify: (req, _res, buf) => {
      req.rawBody = buf;
    }
  })
);
app.use(express.urlencoded({ extended: false, limit: "10mb" }));
app.use((req, res, next) => {
  const start = Date.now();
  const path = req.path;
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path.startsWith("/api")) {
      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
      if (duration > 500) {
        logLine = `\u26A0\uFE0F SLOW ${logLine}`;
      }
      console.log(logLine);
    }
  });
  next();
});
var httpServer = createServer(app);
var isRoutesRegistered = false;
var routesError = null;
async function ensureRoutes() {
  if (isRoutesRegistered) return;
  if (routesError) throw routesError;
  try {
    await registerRoutes(httpServer, app);
    app.use((err, _req, res, next) => {
      const status = err.status || err.statusCode || 500;
      const message = err.message || "Internal Server Error";
      console.error("Server Error:", err.message || err);
      if (res.headersSent) {
        return next(err);
      }
      return res.status(status).json({ message });
    });
    isRoutesRegistered = true;
    console.log("[Vercel] Routes registered successfully");
  } catch (err) {
    routesError = err;
    console.error("[Vercel] Failed to register routes:", err.message || err);
    throw err;
  }
}
var routesPromise = ensureRoutes().catch(() => {
});
async function handler(req, res) {
  try {
    await ensureRoutes();
    return app(req, res);
  } catch (err) {
    console.error("[Vercel] Handler error:", err.message || err);
    res.status(500).json({
      error: "Server initialization failed",
      message: err.message || "Unknown error",
      hint: "Check Environment Variables (DATABASE_URL, SESSION_SECRET) in Vercel Dashboard \u2192 Settings"
    });
  }
}
export {
  handler as default
};
