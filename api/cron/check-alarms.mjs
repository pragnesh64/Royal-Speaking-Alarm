// Auto-generated by build-vercel-api.ts â€” DO NOT EDIT

var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// server/db.ts
import { drizzle } from "drizzle-orm/node-postgres";
import pg from "pg";

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  alarms: () => alarms,
  insertAlarmSchema: () => insertAlarmSchema,
  insertMedicineSchema: () => insertMedicineSchema,
  insertMeetingSchema: () => insertMeetingSchema,
  insertPushSubscriptionSchema: () => insertPushSubscriptionSchema,
  insertUserSchema: () => insertUserSchema,
  medicines: () => medicines,
  meetings: () => meetings,
  otpCodes: () => otpCodes,
  pushSubscriptions: () => pushSubscriptions,
  sessions: () => sessions,
  users: () => users
});
import { pgTable, text, serial, integer, boolean, timestamp, varchar, index, jsonb } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { sql } from "drizzle-orm";
var sessions = pgTable(
  "sessions",
  {
    sid: varchar("sid").primaryKey(),
    sess: jsonb("sess").notNull(),
    expire: timestamp("expire").notNull()
  },
  (table) => [index("IDX_session_expire").on(table.expire)]
);
var users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  email: varchar("email").unique(),
  phone: varchar("phone"),
  passwordHash: varchar("password_hash"),
  authProvider: varchar("auth_provider").default("email"),
  // email, google, phone
  firstName: varchar("first_name"),
  lastName: varchar("last_name"),
  profileImageUrl: varchar("profile_image_url"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
  // App-specific fields
  subscriptionStatus: text("subscription_status").default("trial"),
  trialEndsAt: timestamp("trial_ends_at").defaultNow(),
  language: text("language").default("english"),
  // Stripe fields for payment
  stripeCustomerId: varchar("stripe_customer_id"),
  stripeSubscriptionId: varchar("stripe_subscription_id")
});
var otpCodes = pgTable("otp_codes", {
  id: serial("id").primaryKey(),
  phone: varchar("phone").notNull(),
  code: varchar("code").notNull(),
  expiresAt: timestamp("expires_at").notNull(),
  used: boolean("used").default(false),
  createdAt: timestamp("created_at").defaultNow()
});
var alarms = pgTable("alarms", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").notNull(),
  title: text("title").notNull(),
  time: text("time").notNull(),
  // HH:mm format
  date: text("date"),
  // YYYY-MM-DD for specific date alarms
  days: text("days").array(),
  // ["Mon", "Tue", ...] for recurring
  isActive: boolean("is_active").default(true),
  type: text("type").default("speaking"),
  // speaking, custom_voice, text
  voiceUrl: text("voice_url"),
  // URL to recorded audio or uploaded image
  imageUrl: text("image_url"),
  // New field for alarm photo
  textToSpeak: text("text_to_speak"),
  voiceGender: text("voice_gender").default("female"),
  // male, female
  language: text("language").default("english"),
  // Added language support
  duration: integer("duration").default(30),
  // Duration in seconds to play
  loop: boolean("loop").default(true)
  // Whether to loop the audio/TTS
});
var medicines = pgTable("medicines", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").notNull(),
  name: text("name").notNull(),
  photoUrl: text("photo_url"),
  timeOfDay: text("time_of_day"),
  times: text("times").array(),
  dosage: text("dosage"),
  isActive: boolean("is_active").default(true),
  type: text("type").default("speaking"),
  voiceUrl: text("voice_url"),
  textToSpeak: text("text_to_speak"),
  voiceGender: text("voice_gender").default("female"),
  language: text("language").default("english"),
  duration: integer("duration").default(30),
  loop: boolean("loop").default(true)
});
var meetings = pgTable("meetings", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").notNull(),
  title: text("title").notNull(),
  date: text("date").notNull(),
  // YYYY-MM-DD
  time: text("time").notNull(),
  // HH:mm format
  location: text("location"),
  description: text("description"),
  participants: text("participants"),
  textToSpeak: text("text_to_speak"),
  enabled: boolean("enabled").default(true)
});
var pushSubscriptions = pgTable("push_subscriptions", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").notNull(),
  endpoint: text("endpoint").notNull(),
  p256dh: text("p256dh").notNull(),
  auth: text("auth").notNull(),
  createdAt: timestamp("created_at").defaultNow()
});
var insertUserSchema = createInsertSchema(users);
var insertAlarmSchema = createInsertSchema(alarms).omit({ id: true });
var insertMedicineSchema = createInsertSchema(medicines).omit({ id: true });
var insertMeetingSchema = createInsertSchema(meetings).omit({ id: true });
var insertPushSubscriptionSchema = createInsertSchema(pushSubscriptions).omit({ id: true });

// server/db.ts
var { Pool } = pg;
if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?"
  );
}
var isNeon = (process.env.DATABASE_URL || "").includes("neon.tech");
var pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  // Pool sizing
  max: 10,
  // max connections in pool
  min: 2,
  // keep 2 warm connections ready
  // Timeouts
  idleTimeoutMillis: 3e4,
  // close idle connections after 30s
  connectionTimeoutMillis: 1e4,
  // fail fast if can't connect in 10s
  // Keep connections warm (critical for remote DBs like Neon)
  keepAlive: true,
  keepAliveInitialDelayMillis: 1e4,
  // SSL required for Neon and most cloud DBs
  ssl: isNeon ? { rejectUnauthorized: false } : void 0
});
pool.on("error", (err) => {
  console.error("[DB] Pool connection error (non-fatal):", err.message);
});
pool.query("SELECT 1").then(() => {
  console.log("[DB] Connection pool warmed up");
}).catch((err) => {
  console.error("[DB] Pool warm-up failed:", err.message);
});
var db = drizzle(pool, { schema: schema_exports });

// server/vercel-cron.ts
import { eq as eq2 } from "drizzle-orm";

// server/pushNotification.ts
import webPush from "web-push";
import { eq } from "drizzle-orm";
var vapidKeys = {
  publicKey: process.env.VAPID_PUBLIC_KEY || "",
  privateKey: process.env.VAPID_PRIVATE_KEY || ""
};
if (!vapidKeys.publicKey || !vapidKeys.privateKey) {
  const generatedKeys = webPush.generateVAPIDKeys();
  vapidKeys = generatedKeys;
  console.log("[Push] Generated VAPID keys. Add these to environment:");
  console.log("VAPID_PUBLIC_KEY=" + generatedKeys.publicKey);
  console.log("VAPID_PRIVATE_KEY=" + generatedKeys.privateKey);
}
webPush.setVapidDetails(
  "mailto:support@mypa.app",
  vapidKeys.publicKey,
  vapidKeys.privateKey
);
async function sendPushNotification(userId, payload) {
  const subscriptions = await db.select().from(pushSubscriptions).where(eq(pushSubscriptions.userId, userId));
  let success = 0;
  let failed = 0;
  for (const sub of subscriptions) {
    try {
      await webPush.sendNotification(
        {
          endpoint: sub.endpoint,
          keys: {
            p256dh: sub.p256dh,
            auth: sub.auth
          }
        },
        JSON.stringify(payload),
        {
          TTL: 60,
          urgency: "high",
          headers: {
            "Urgency": "high"
          }
        }
      );
      success++;
      console.log(`[Push] Notification sent to user ${userId}`);
    } catch (error) {
      failed++;
      console.error(`[Push] Failed to send notification:`, error.message);
      if (error.statusCode === 410 || error.statusCode === 404) {
        await db.delete(pushSubscriptions).where(eq(pushSubscriptions.id, sub.id));
        console.log(`[Push] Removed invalid subscription ${sub.id}`);
      }
    }
  }
  return { success, failed };
}

// server/vercel-cron.ts
function getCurrentTimeIST() {
  const now = /* @__PURE__ */ new Date();
  const options = {
    timeZone: "Asia/Kolkata",
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
    weekday: "short",
    year: "numeric",
    month: "2-digit",
    day: "2-digit"
  };
  const formatter = new Intl.DateTimeFormat("en-IN", options);
  const parts = formatter.formatToParts(now);
  const getValue = (type) => parts.find((p) => p.type === type)?.value || "";
  const hours = getValue("hour").padStart(2, "0");
  const minutes = getValue("minute").padStart(2, "0");
  const time = `${hours}:${minutes}`;
  const weekdayMap = {
    "Sun": "Sun",
    "Mon": "Mon",
    "Tue": "Tue",
    "Wed": "Wed",
    "Thu": "Thu",
    "Fri": "Fri",
    "Sat": "Sat"
  };
  const day = weekdayMap[getValue("weekday")] || getValue("weekday");
  const year = getValue("year");
  const month = getValue("month").padStart(2, "0");
  const dateNum = getValue("day").padStart(2, "0");
  const date = `${year}-${month}-${dateNum}`;
  return { time, day, date };
}
function timeMatches(alarmTime, currentTime) {
  return alarmTime.substring(0, 5) === currentTime;
}
async function handler(req, res) {
  const authHeader = req.headers?.authorization;
  if (process.env.CRON_SECRET && authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return res.status(401).json({ error: "Unauthorized" });
  }
  const { time, day, date } = getCurrentTimeIST();
  console.log(`[Cron] Checking at ${time} on ${day} (${date})`);
  try {
    const [activeAlarms, activeMedicines, activeMeetings] = await Promise.all([
      db.select().from(alarms).where(eq2(alarms.isActive, true)),
      db.select().from(medicines).where(eq2(medicines.isActive, true)),
      db.select().from(meetings).where(eq2(meetings.enabled, true))
    ]);
    const pushPromises = [];
    for (const alarm of activeAlarms) {
      let shouldTrigger = false;
      if (timeMatches(alarm.time, time)) {
        if (alarm.date) {
          shouldTrigger = alarm.date === date;
        } else if (alarm.days && alarm.days.length > 0) {
          shouldTrigger = alarm.days.includes(day);
        } else {
          shouldTrigger = true;
        }
      }
      if (shouldTrigger) {
        pushPromises.push(
          sendPushNotification(alarm.userId, {
            title: alarm.title || "MyPA Alarm",
            body: alarm.textToSpeak || `${alarm.title} - Time!`,
            type: "alarm",
            id: alarm.id,
            textToSpeak: alarm.textToSpeak || void 0,
            alarmType: alarm.type || "speaking",
            voiceUrl: alarm.voiceUrl || void 0,
            imageUrl: alarm.imageUrl || void 0,
            language: alarm.language || "english",
            days: alarm.days || void 0,
            duration: alarm.duration || 30,
            loop: alarm.loop !== false,
            voiceGender: alarm.voiceGender || "female"
          })
        );
      }
    }
    for (const medicine of activeMedicines) {
      if (medicine.times?.length) {
        for (const medTime of medicine.times) {
          if (timeMatches(medTime, time)) {
            pushPromises.push(
              sendPushNotification(medicine.userId, {
                title: `Medicine: ${medicine.name}`,
                body: medicine.textToSpeak || `Time to take ${medicine.name}`,
                type: "medicine",
                id: medicine.id
              })
            );
          }
        }
      }
    }
    for (const meeting of activeMeetings) {
      if (timeMatches(meeting.time, time) && meeting.date === date) {
        pushPromises.push(
          sendPushNotification(meeting.userId, {
            title: `Meeting: ${meeting.title}`,
            body: meeting.textToSpeak || meeting.title,
            type: "meeting",
            id: meeting.id
          })
        );
      }
    }
    let results = { sent: 0, failed: 0 };
    if (pushPromises.length > 0) {
      const settled = await Promise.allSettled(pushPromises);
      results.sent = settled.filter((r) => r.status === "fulfilled").length;
      results.failed = settled.filter((r) => r.status === "rejected").length;
    }
    return res.status(200).json({ ok: true, time, day, date, notifications: results });
  } catch (error) {
    console.error("[Cron] Error:", error.message);
    return res.status(500).json({ error: error.message });
  }
}
export {
  handler as default
};
